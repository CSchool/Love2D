\section{Lua за 15 минут}

\lstset{style=Lua}

Данное пособие является адаптацией статьи ``Learn Lua in 15 Minutes'' с некоторыми дополнениями. 
Оригинал на английском языке можно найти по адресу: \url{http://tylerneylon.com/a/learn-lua/}.

\subsection{Комментарии}

Комментарии в Lua можно сделать двумя способами:

\begin{lstlisting}
-- One line comment
	
--[[
    first line
    seconde line
--]]
\end{lstlisting}

Первый способ начинает однострочный комментарий, второй~---~многострочный.

\subsection{Переменные (простые типы)}

Все числовые переменные являются вещественными (double):

\begin{lstlisting}
number = 42
another_number = 3.1415
\end{lstlisting}

Над числами можно проводить следующие операции: сложение (\lstinline{+}), вычитание (\lstinline{-}), 
умножение (\lstinline{*}), деление (\lstinline{/}), возведение в  степень (\lstinline{^}):

\begin{lstlisting}
add = 5 + 3 -- add = 8
sub = add - 4 -- sub = 4
mult = add * sub -- mult = 32
div = add / sub -- div = 2
pow = 2^3 -- pow = 8
\end{lstlisting}

Строки в языка Lua являются \emph{неизменяемыми}, то есть нельзя обратиться к индексу строки и поменять символ.
Объявление сток можно сделать тремя способами:

\begin{lstlisting}
color = 'black'
season = "summer"
huge_string = [[ This is
	a very-very
	long string! ]]
\end{lstlisting}

Для соединения строк (\emph{конкатенация} строк) используется оператор $..$:

\begin{lstlisting}
name = "Petr"
surname = "Ivanov"
pupil = name .. " " .. surname -- pupil = "Petr Ivanov"
\end{lstlisting}

Если при конкатенации строк будут использоваться числовые переменные, то они автоматически будут приведены к строкам:

\begin{lstlisting}
number = 42
question = number .. " is good answer for everything!"
-- question = "42 is good answer for everything!"
\end{lstlisting}

Переменные могут принимать логическое значение \emph{boolean}: \textbf{true} (истина) или \textbf{ложь}:

\begin{lstlisting}
to_be_or_not_to_be = true
\end{lstlisting}

Переменные также могут принимать значение \emph{nil}. Данный тип означает, что значения у переменной \textbf{не существует}!

\begin{lstlisting}
aliens_exist = nil
\end{lstlisting}

\subsection{Логические операторы}

Существуют следующие логические операторы: \lstinline{and}, \lstinline{or} и \lstinline{not}.
Все логические операторы предполагают, что \lstinline{false} и \lstinline{nil} представляют собой значение \textbf{false}, 
а все остальные значения~---~\textbf{true}.

Оператор \lstinline{and} возвращает первый аргумент в том случае, если его значение \emph{false}, 
в противном случае возвращается второй аргумент.
Оператор \lstinline{or} возвращает  первый аргумент в том случае, если его значение \emph{true},
в противном случае возвращается второй аргумент.

\begin{lstlisting}
print(4 and 5)         -- 5
print(nil and 13)      -- nil
print(false and 13)    -- false
print(4 or 5)          -- 4
print(false or 5)      -- 5
\end{lstlisting}

Операторы \lstinline{and} и \lstinline{or} не вычисляют второй аргумент, если в это нет необходимости.
Например, выражение \lstinline{x = x or v} эквивалентно следующему выражению:

\begin{lstlisting}
if not x then x = v end
\end{lstlisting}

То есть, если значение \lstinline{x} не существует, то ставится значение \lstinline{v}.

Ещё один вариант использования условных операторов: реализация тернарного оператора (\lstinline{a ? b : c}). В языке Lua его можно реализовать следующим способом:

\begin{lstlisting}
a and b or c -- (a and b) or c
\end{lstlisting}

Пример выбора максимального значения из двух чисел:

\begin{lstlisting}
max = (x > y) and x or y
\end{lstlisting}

Сперва вычисляется выражение \lstinline{x > y}. Если оно имеет значение \lstinline{true}, то срабатывает \lstinline{(x > y)    and x} и возвращается \lstinline{x}, так как \lstinline{x}~---~число и всегда равен значению \lstinline{true}. 
Если же выражение  \lstinline{x > y} имеет значение \lstinline{false}, 
то выражение \lstinline{(x > y)   and x} возвращает \lstinline{false}, оно сравнивается с \lstinline{y}, 
и оператор \lstinline{or} возвращает значение \lstinline{y}.

Оператор \lstinline{not} всегда возвращает \lstinline{true} или \lstinline{false}:

\begin{lstlisting}
print(not nil)      -- true
print(not false)    -- true
print(not 0)        -- false
print(not not nil)  -- false
\end{lstlisting}

\subsection{Операторы отношений}

В языке Lua выделяются следующие операторы отношений, каждый из которых возвращает \lstinline{true} или \lstinline{false}:

\begin{lstlisting}
<   >   <=  >=  ==  ~=
\end{lstlisting}

Оператор $==$ проверяет равенство аргументов, а оператор \lstinline{~=}~---~неравенство:

\begin{lstlisting}
print(5 == 6) -- false
print(52 ~= 0) -- true
\end{lstlisting}

\subsection{Условный оператор if}

Условия в языке Lua записываются при помощи условного оператора \lstinline{if}:

\begin{lstlisting}
if statement then
... -- do something if statement == true
end
\end{lstlisting}

Оператор проверяет условие \emph{statement} и выполняет операции между ключевыми словами \lstinline{then} и \lstinline{end} только в том случае, если \emph{statement}~---~истинен.

Примеры условий:

\begin{lstlisting}
if a < 0 then a = 0 end

if object == "car" then
  print("This is car!")
end
\end{lstlisting}

Можно задавать поведение условного оператора \lstinline{if} при помощи ключевого слова \lstinline{else}, в случае, если условие \emph{statement}~---~ложно:

\begin{lstlisting}
if statement then
... -- statement == true
else
... -- statement == false
end
\end{lstlisting}

Пример использования:

\begin{lstlisting}
if age < 18 then
  print("You can't go to this movie!")
else
  print("Your age is allowed for this movie")
end
\end{lstlisting}

Иногда могут понадобится для работы множественные ветвления (\lstinline{elseif}) условного оператора \lstinline{if}:

\begin{lstlisting}
if op == "+" then
  r = a + b
elseif op == "-" then
  r = a - b
elseif op == "*" then
  r = a*b
elseif op == "/" then
  r = a/b
else
  print("Error!")
end
\end{lstlisting}

Отрицание логического выражения \emph{statement} задается при помощи ключевого слова \lstinline{not}:

\begin{lstlisting}
if not end_of_game then ... end
\end{lstlisting}

Выражение \emph{statement} может содержать в себе сложные логические выражения:

\begin{lstlisting}
if age >= 14 and age <= 18 then ... end
\end{lstlisting}

\subsection{Циклы}

Циклы~---~это управляющая конструкция, которая позволяет многократно исполнять ряд инструкций.

\subsubsection{While}

Цикл с предусловием (\lstinline{while})~---~это цикл, который будет выполняться, пока истинно условие (\lstinline{true}). То есть если условие истинно, цикл выполняется, иначе он заканчивает свою работу и управление передается коду за ним. 

\begin{lstlisting}
num = 0
while num < 3 do
  num = num + 1;
  print(num);
end     
\end{lstlisting}

В результате будет выведено: 
\\* 1 
\\* 2
\\* 3

\subsubsection{Repeat}

Цикл с предусловием (\lstinline{repeat})~---~цикл, который так же будет выполняться, пока условие истинно (\lstinline{true}), но проверка условия выполняется после прохождеия тела цикла. То есть тело цикла всегда будет выполняться хотя бы один раз, в отличие от цикла while, который может вообще не выполниться. 

\begin{lstlisting}
num = 3
repeat
  print(num)
  num = num - 1
until num == 0    
\end{lstlisting}

В результате будет выведено:
\\* 3
\\* 2
\\* 1

\subsubsection{Числовой for}
Счетный цикл или цикл со счетчиком (\lstinline{for})~---~цикл, в котором некоторая заданная переменная меняет свое значение от заданного начального значения до заданного конечного в соответсвии с указанным шагом. 

Синтаксис счетного цикла: 
\begin{lstlisting}
for var=exp1,exp2,exp3 do
  something
end
\end{lstlisting}

Действие \emph{something} будет исполняться для каждого значения управляющей переменной \emph{var} от начального значения \emph{exp1} до конечного значения \emph{exp2} с шагом \emph{exp3}. Указывать шаг \textbf{необязательно}, так как по умолчанию шаг равен 1.

\begin{lstlisting}
for var=0,6,2 do
  print(var) 
end
\end{lstlisting}

В результате будет выведено:
\\* 0
\\* 2
\\* 4
\\* 6

\emph{Замечания}:
\begin{itemize}
	\item Управляющая переменная \emph{var} является локальной, то есть видна только в пределах цикла, а в не его не существует.
	\item Если в качестве одного из \emph{exp} стоит функция, то она будет вызвана всего один раз перед началом цикла, то есть при изменении значения переменных, передаваемых в цикл, граница цикла все равно не изменится. 
	\item Не следует менять значение управляющей переменной, так как тогда поведение будет непредсказуемым. Если есть необходимость остановить цикл, лучше использовать оператор \lstinline{break}.
\end{itemize}

		   
\begin{lstlisting}
var = 3
for i = 1,10 do
  if i >= var then
    break
  else
    print(i .. "is less then 3")
  end
end
\end{lstlisting}

В результате будет выведено: 
\\* 1 is less then 3
\\* 2 is less then 3

\subsubsection{Общий for}

Совместный цикл или цикл с итератором(for)~---~цикл, который позволяет обходить все значения, которые возвращаются функцией итератора. Итератор предоставляет нам доступ к элементам коллекции(массива) и обеспечивает навигацию по ней. Говоря простым языком, совместный цикл позволяет нам "пройтись" по всем элементам массива или другого объединения, последовательно получая индексы и/или значения. 

\begin{lstlisting}
for i,v in ipairs(a) do 
  print(v) 
end
\end{lstlisting}

За один шаг цикла в \emph{i} помещается очередной индекс массива \emph{a}, а в \emph{v} значение, ассоциируемое с данным индексом. 

Стандартные функции-итераторы:
\begin{itemize}
	\item io.lines - обход строк в файле
	\item pairs - пар в массиве(таблице)
	\item string.gfind - слов в строке 
	\item и т.д.
\end{itemize}

  
\subsection{Присваивание}

Присваивание означает изменение(запись) значения переменной или поля таблицы(массива)~---~ смотри секцию~\ref{subsec:tables}.

\begin{lstlisting}
str = "Hello" .. "World"
number = number + 1
\end{lstlisting}

Lua позволяет проивзодить множественное присваивание, то есть список значений присваивается списку переменных за один шаг. Элементы обоиз списков разделяются запятыми. 

\begin{lstlisting}
str, number = "Hello" .. "World", number + 1
\end{lstlisting}

Переменной \emph{str} будет присвоено значение \emph{Hello World}, в то время как значение переменной \emph{number} увеличится на единицу. 

В Lua сначала производится оценка переменных, а затем выполняется присваивание. Благодаря этому, мы можем произвести обмен значениями переменых за один шаг

\begin{lstlisting}
 x, y = y, x                -- swap x and y
 a[i], a[j] = a[j], a[i]    -- swap a[i] and a[j]
\end{lstlisting}

Если количество переменных отлично от количества значений, то:
\begin{enumerate}
	\item Если количество переменных больше количества значений, то переменым, которым не представлены значения получат значение \emph{nil}
	\item Если количество переменных меньше количества значений, то лишние значения будут проигнорированы
\end{enumerate}

\begin{lstlisting}
    a, b, c =  1, 2
    print(a,b,c)           --> 1  2   nil
    a, b = 1, 2, 3   	   -- 3 ignores
    print(a,b)             --> 1   2
    a, b, c = "Hello"
    print(a,b,c)           --> "Hello"   nil   nil
\end{lstlisting}

\subsection{Блоки. Глобальные и локальные переменные} 

Блок ограничивает логически сгруппированный набор идущих подряд инструкций и ограничивает область видимости переменных. Блоком является любая управляющая конструкция(циклы, условные конструкции после \lstinline{then} и \lstinline{else}, функции), а также файл, в котором исполняется скрипт. Блоки могут быть вложенными. Для создания блока используется конструкция \lstinline{do}-\lstinline{end}.
\begin{lstlisting}
do
  --some instructions
end         
\end{lstlisting}

\begin{lstlisting}
str = "Hello World"      -- global
local x = 10 			-- local
\end{lstlisting}

Все переменные объявленые в lua в любом блоке являются глобальными, если они не помечены служебным словом \lstinline{local}.
\lstinline{local} указывает на то, что переменная будет локальна, то есть сущесвтует только в пределах блока, в котором она объявлена. 

\begin{lstlisting}
x = 10
i = 1  
    
while i <= x do
  local x = i*2     -- local for "while" body
  print(x)          --> 2, 4, 6, 8, ...
  i = i + 1
end
  
if i > 20 then
  local x           -- local for "then" body
  x = 20
  print(x + 2)	  --> 22
else
  print(x)         --> 10 (global)
end
    
print(x)             --> 10 (global)
\end{lstlisting}

\subsection{Таблицы}
\label{subsec:tables}

\subsubsection{Общая информация}

Таблица представляет собой ассоциативный массив. Ассоциативный массив~---~это массив, в котором индексы не обязательно должны являться числами, а могут быть представлены и другими типами(кроме \lstinline{nil}, то есть это множество пар "ключ-значение". У таблицы нет фиксированного размера, она может динамически увеличиваться. Таблица может хранить значения различных типов. Если значение поля не задано, то оно будет равно \lstinline{nil}. 

Таблицы используются для представления обычных массивов, очередей, множеств и других структур данных. В Lua таблицы являются объектами. Объект~---~это некоторая сущность, обладающая определенным состоянием и поведением, имеющая заданные свойства и методы, которые производят операции над ними. При работе с объектами, на самом деле мы манипулируем ссылками на них в памяти. Таблицы объявляются при помощи специального выражения  конструктора~---~\{\}. 

\begin{lstlisting}
table = {}
table[1] = 4
table[2] = "Hello"
table["some"] = 1
print(table[1] + table["some"])     --> 5
print(table[2] .." " .. table[1])   --> Hello 4
print(table["other"])               --> nil
\end{lstlisting}

Работая с таблицей, мы обращаемся к указателю(ссылке) на нее в виртуальном адресном пространстве.
В следующем ниже примере переменная \emph{b} будет указывать на ту же самую таблицу, что и \emph{a}.
\begin{lstlisting}
a = {}
a["x"] = 10
b = a  -- "b" refers to the same table as "a"  

print(b["x"]) --> 10
b[2] = 5
print(a[2]) --> 5
   
a = nil -- "a" no longer refers to the table
b = nil -- "b" also doesn't refer to the table, there isn't any reference to the table 
\end{lstlisting} 

Таблица существует в памяти до тех пор, пока на нее указывает хоть одна переменная, как только закончатся все ссылки на таблцу, она будет удалена, и память будут освобождена.

Lua допускает другую форму обращения к элементу таблицы, индекс которой является строкой. 

\begin{lstlisting}
a.x = 10 -- same as a["x"] = 10
\end{lstlisting}

Стоит отметить, что \emph{a.x} означает именно обращение к индексу \emph{"x"}, но никак не \emph{x}. 

Если индекс содержит специальные символы, то обращаться к индексу через оператор []:

\begin{lstlisting}
a = {}
a["this-is-my-special-key"] = "value";
\end{lstlisting}

Таблицу можно инициализировать при помощи ключей:

\begin{lstlisting}
a = {
  name = "Petr",
  surname = "Ivanov"
}

print(a.name) -- Petr
print(a.surname) -- Ivanov
\end{lstlisting}

Размер таблицы можно узнать при помощи оператора \lstinline{#}:

\begin{lstlisting}
my_table = {10, 22, 35, 47}
print(#my_table) --> 4
\end{lstlisting}

\subsubsection{Итерация элементов таблицы}

Итерацию элементов (перебор всех элементов) можно осуществить при помощи конструкции \lstinline{for .. in pairs}:

\begin{lstlisting}
a = {
  ["Blondie"] = "Good",
  ["Angel Eyes"] = "Bad",
  ["Tuco"] = "Ugly"
}

for i,v in pairs(a) do print("Person " .. i .. " is " .. v) end
\end{lstlisting}

Вывод на экран:

\begin{lstlisting}
  Person Tuco is Ugly
  Person Blondie is Good
  Person Angel Eyes is Bad
\end{lstlisting}


В данном примере в цикле \lstinline{for} в переменную \emph{i} помещаются ключи таблицы, а в \emph{v}~---~значения. 
Ключи могут быть как и числами, так и строками. Необходимо помнить, что порядок обхода элементов при использовании \lstinline{for .. in pairs} является \emph{случайным}!

Если все ключи в таблице являются числами, то можно использовать конструкцию \lstinline{for .. in ipairs}:

\begin{lstlisting}
t = { "a", "b", "c", "d" }  
for i, v in ipairs(t) do  
  print(i .. ": " .. v)   
end  
\end{lstlisting}

Результат выполнения:

\begin{lstlisting}
  1: a
  2: b
  3: c
  4: d
\end{lstlisting}

Отличие от \lstinline{for .. in pairs} в том, что ключ является целочисленным, начинается с 1, и с каждой итерацией увеличивается на 1. Если во время обхода таблицы будет встречен ключ-строка, то он будет проигнорирован, если же попадет ключ, который равен \lstinline{nil}, то обход массива будет прекращен!

\begin{lstlisting}
t = { "a", ["test"] = "f", "b", "c", ["name"] = 5, "d", nil, 6 }  
for i, v in ipairs(t) do  
  print(i .. ": " .. v)   
end  
\end{lstlisting}

Результат выполнения:

\begin{lstlisting}
  1: a
  2: b
  3: c
  4: d
\end{lstlisting}

\subsubsection{Массивы}

Массивы можно реализовать при помощи таблиц, используя в качестве ключей числа. 
У массивов нет ограничений по количеству элементов, и они ``растут'' когда это понадобится.

Пример инициализации массивов:

\begin{lstlisting}
a = {}    -- new array
for i=1, 1000 do
  a[i] = i + 2 
end
\end{lstlisting}

Массивы можно инициализировать также таким способом:

\begin{lstlisting}
squares = {1, 4, 9, 16, 25, 36, 49, 64, 81}
\end{lstlisting}

Необходимо обратить внимание, что индексация массивов в языке Lua начинаются с \textbf{1}, а не с 0!
Стандартные функции по работе с таблицами подразумевают, что массивы индексируются с 1.
Однако, при инициализации можно задать другие границы массива:

\begin{lstlisting}
a = {}
for i=-5, 5 do
  a[i] = 0
end 
\end{lstlisting}

Двумерные массивы можно реализовать двумя способами:

\begin{itemize}
	\item Создать массив из \emph{N} элементов. Каждый элемент массива - это ещё один массив размера \emph{M}:
	
\begin{lstlisting}
mt = {}          -- create the matrix
for i=1,N do
  mt[i] = {}     -- create a new row
  for j=1,M do
    mt[i][j] = 0
  end
end
\end{lstlisting}

	\item Создать \emph{одномерный} массив из $N * M$ элементов и добавлять элементы по следующему правилу (смотри 4-ую строку):

\begin{lstlisting}
mt = {}          -- create the matrix
for i=1,N do
  for j=1,M do
    mt[i*M + j] = 0
  end
end
\end{lstlisting}
	
\end{itemize}

Такими же способами можно создавать N-мерные массивы.

\subsubsection{Множества (Sets)}

При помощи таблиц в Lua можно реализовать множества, если в качестве ключа передавать необходимое значение (число или строку), 
а в качестве значения~---~\lstinline{true}. Проверять наличие элемента можно такой конструкцией: \lstinline{if set[element] then ... end}, где \emph{set}~---~множество, а \emph{element}~---~искомый элемент.

Пример множества:

\begin{lstlisting}
set = {}

for i = 2, 10, 2 do
  set[i] = true
end

for i = 1, 10 do
  if set[i] then
    print(i .. " in set")  
  end
end
\end{lstlisting}

