\section{Lua за 15 минут}

\lstset{style=Lua}

Данное пособие является адаптацией статьи ``Learn Lua in 15 Minutes'' с некоторыми дополнениями. 
Оригинал на английском языке можно найти по адресу: \url{http://tylerneylon.com/a/learn-lua/}.

\subsection{Комментарии}

Комментарии в Lua можно сделать двумя способами:

\begin{lstlisting}
-- One line comment
	
--[[
    first line
    seconde line
--]]
\end{lstlisting}

Первый способ начинает однострочный комментарий, второй~---~многострочный.

\subsection{Переменные (простые типы)}

Все числовые переменные являются вещественными (double):

\begin{lstlisting}
number = 42
another_number = 3.1415
\end{lstlisting}

Над числами можно проводить следующие операции: сложение (\lstinline{+}), вычитание (\lstinline{-}), 
умножение (\lstinline{*}), деление (\lstinline{/}), возведение в  степень (\lstinline{^}):

\begin{lstlisting}
add = 5 + 3 -- add = 8
sub = add - 4 -- sub = 4
mult = add * sub -- mult = 32
div = add / sub -- div = 2
pow = 2^3 -- pow = 8
\end{lstlisting}

Строки в языка Lua являются \emph{неизменяемыми}, то есть нельзя обратиться к индексу строки и поменять символ.
Объявление сток можно сделать тремя способами:

\begin{lstlisting}
color = 'black'
season = "summer"
huge_string = [[ This is
	a very-very
	long string! ]]
\end{lstlisting}

Для соединения строк (\emph{конкатенация} строк) используется оператор $..$:

\begin{lstlisting}
name = "Petr"
surname = "Ivanov"
pupil = name .. " " .. surname -- pupil = "Petr Ivanov"
\end{lstlisting}

Если при конкатенации строк будут использоваться числовые переменные, то они автоматически будут приведены к строкам:

\begin{lstlisting}
number = 42
question = number .. " is good answer for everything!"
-- question = "42 is good answer for everything!"
\end{lstlisting}

Переменные могут принимать логическое значение \emph{boolean}: \textbf{true} (истина) или \textbf{ложь}:

\begin{lstlisting}
to_be_or_not_to_be = true
\end{lstlisting}

Переменные также могут принимать значение \emph{nil}. Данный тип означает, что значения у переменной \textbf{не существует}!

\begin{lstlisting}
aliens_exist = nil
\end{lstlisting}

\subsection{Логические операторы}

Существуют следующие логические операторы: \lstinline{and}, \lstinline{or} и \lstinline{not}.
Все логические операторы предполагают, что \lstinline{false} и \lstinline{nil} представляют собой значение \textbf{false}, 
а все остальные значения~---~\textbf{true}.

Оператор \lstinline{and} возвращает первый аргумент в том случае, если его значение \emph{false}, 
в противном случае возвращается второй аргумент.
Оператор \lstinline{or} возвращает  первый аргумент в том случае, если его значение \emph{true},
в противном случае возвращается второй аргумент.

\begin{lstlisting}
print(4 and 5)         -- 5
print(nil and 13)      -- nil
print(false and 13)    -- false
print(4 or 5)          -- 4
print(false or 5)      -- 5
\end{lstlisting}

Операторы \lstinline{and} и \lstinline{or} не вычисляют второй аргумент, если в это нет необходимости.
Например, выражение \lstinline{x = x or v} эквивалентно следующему выражению:

\begin{lstlisting}
if not x then x = v end
\end{lstlisting}

То есть, если значение \lstinline{x} не существует, то ставится значение \lstinline{v}.

Ещё один вариант использования условных операторов: реализация тернарного оператора (\lstinline{a ? b : c}). В языке Lua его можно реализовать следующим способом:

\begin{lstlisting}
a and b or c -- (a and b) or c
\end{lstlisting}

Пример выбора максимального значения из двух чисел:

\begin{lstlisting}
max = (x > y) and x or y
\end{lstlisting}

Сперва вычисляется выражение \lstinline{x > y}. Если оно имеет значение \lstinline{true}, то срабатывает \lstinline{(x > y)    and x} и возвращается \lstinline{x}, так как \lstinline{x}~---~число и всегда равен значению \lstinline{true}. 
Если же выражение  \lstinline{x > y} имеет значение \lstinline{false}, 
то выражение \lstinline{(x > y)   and x} возвращает \lstinline{false}, оно сравнивается с \lstinline{y}, 
и оператор \lstinline{or} возвращает значение \lstinline{y}.

Оператор \lstinline{not} всегда возвращает \lstinline{true} или \lstinline{false}:

\begin{lstlisting}
print(not nil)      -- true
print(not false)    -- true
print(not 0)        -- false
print(not not nil)  -- false
\end{lstlisting}

\subsection{Операторы отношений}

В языке Lua выделяются следующие операторы отношений, каждый из которых возвращает \lstinline{true} или \lstinline{false}:

\begin{lstlisting}
<   >   <=  >=  ==  ~=
\end{lstlisting}

Оператор $==$ проверяет равенство аргументов, а оператор \lstinline{~=}~---~неравенство:

\begin{lstlisting}
print(5 == 6) -- false
print(52 ~= 0) -- true
\end{lstlisting}

\subsection{Условный оператор if}

Условия в языке Lua записываются при помощи условного оператора \lstinline{if}:

\begin{lstlisting}
if statement then
... -- do something if statement == true
end
\end{lstlisting}

Оператор проверяет условие \emph{statement} и выполняет операции между ключевыми словами \lstinline{then} и \lstinline{end} только в том случае, если \emph{statement}~---~истинен.

Примеры условий:

\begin{lstlisting}
if a < 0 then a = 0 end

if object == "car" then
  print("This is car!")
end
\end{lstlisting}

Можно задавать поведение условного оператора \lstinline{if} при помощи ключевого слова \lstinline{else}, в случае, если условие \emph{statement}~---~ложно:

\begin{lstlisting}
if statement then
... -- statement == true
else
... -- statement == false
end
\end{lstlisting}

Пример использования:

\begin{lstlisting}
if age < 18 then
  print("You can't go to this movie!")
else
  print("Your age is allowed for this movie")
end
\end{lstlisting}

Иногда могут понадобится для работы множественные ветвления (\lstinline{elseif}) условного оператора \lstinline{if}:

\begin{lstlisting}
if op == "+" then
  r = a + b
elseif op == "-" then
  r = a - b
elseif op == "*" then
  r = a*b
elseif op == "/" then
  r = a/b
else
  print("Error!")
end
\end{lstlisting}

Отрицание логического выражения \emph{statement} задается при помощи ключевого слова \lstinline{not}:

\begin{lstlisting}
if not end_of_game then ... end
\end{lstlisting}

Выражение \emph{statement} может содержать в себе сложные логические выражения:

\begin{lstlisting}
if age >= 14 and age <= 18 then ... end
\end{lstlisting}

\subsection{Циклы}

Циклы~---~это управляющая конструкция, которая позволяет многократно исполнять ряд инструкций.

\subsubsection{While}

Цикл с предусловием (\lstinline{while})~---~это цикл, который будет выполняться, пока истинно условие (\lstinline{true}). То есть если условие истинно, цикл выполняется, иначе он заканчивает свою работу и управление передается коду за ним. 

\begin{lstlisting}
num = 0
while num < 3 do
  num = num + 1;
  print(num);
end     
\end{lstlisting}

В результате будет выведено: 
\\* 1 
\\* 2
\\* 3

\subsubsection{Repeat}

Цикл с предусловием (\lstinline{repeat})~---~цикл, который так же будет выполняться, пока условие истинно (\lstinline{true}), но проверка условия выполняется после прохождеия тела цикла. То есть тело цикла всегда будет выполняться хотя бы один раз, в отличие от цикла while, который может вообще не выполниться. 

\begin{lstlisting}
num = 3
repeat
  print(num)
  num = num - 1
until num == 0    
\end{lstlisting}

В результате будет выведено:
\\* 3
\\* 2
\\* 1

\subsubsection{Числовой for}
Счетный цикл или цикл со счетчиком (\lstinline{for})~---~цикл, в котором некоторая заданная переменная меняет свое значение от заданного начального значения до заданного конечного в соответсвии с указанным шагом. 

Синтаксис счетного цикла: 
\begin{lstlisting}
for var=exp1,exp2,exp3 do
  something
end
\end{lstlisting}

Действие \emph{something} будет исполняться для каждого значения управляющей переменной \emph{var} от начального значения \emph{exp1} до конечного значения \emph{exp2} с шагом \emph{exp3}. Указывать шаг \textbf{необязательно}, так как по умолчанию шаг равен 1.

\begin{lstlisting}
for var=0,6,2 do
  print(var) 
end
\end{lstlisting}

В результате будет выведено:
\\* 0
\\* 2
\\* 4
\\* 6

\emph{Замечания}:
\begin{itemize}
	\item Управляющая переменная \emph{var} является локальной, то есть видна только в пределах цикла, а в не его не существует.
	\item Если в качестве одного из \emph{exp} стоит функция, то она будет вызвана всего один раз перед началом цикла, то есть при изменении значения переменных, передаваемых в цикл, граница цикла все равно не изменится. 
	\item Не следует менять значение управляющей переменной, так как тогда поведение будет непредсказуемым. Если есть необходимость остановить цикл, лучше использовать оператор \lstinline{break}.
\end{itemize}

		   
\begin{lstlisting}
var = 3
for i = 1,10 do
  if i >= var then
    break
  else
    print(i .. "is less then 3")
  end
end
\end{lstlisting}

В результате будет выведено: 
\\* 1 is less then 3
\\* 2 is less then 3

\subsubsection{Общий for}

Совместный цикл или цикл с итератором(for)~---~цикл, который позволяет обходить все значения, которые возвращаются функцией итератора. Итератор предоставляет нам доступ к элементам коллекции(массива) и обеспечивает навигацию по ней. Говоря простым языком, совместный цикл позволяет нам "пройтись" по всем элементам массива или другого объединения, последовательно получая индексы и/или значения. 

\begin{lstlisting}
for i,v in ipairs(a) do 
  print(v) 
end
\end{lstlisting}

За один шаг цикла в \emph{i} помещается очередной индекс массива \emph{a}, а в \emph{v} значение, ассоциируемое с данным индексом. 

Стандартные функции-итераторы:
\begin{itemize}
	\item io.lines - обход строк в файле
	\item pairs - пар в массиве(таблице)
	\item string.gfind - слов в строке 
	\item и т.д.
\end{itemize}

  
\subsection{Присваивание}

Присваивание означает изменение(запись) значения переменной или поля таблицы(массива).

\begin{lstlisting}
str = "Hello" .. "World"
number = number + 1
\end{lstlisting}

Lua позволяет проивзодить множественное присваивание, то есть список значений присваивается списку переменных за один шаг. Элементы обоиз списков разделяются запятыми. 

\begin{lstlisting}
str, number = "Hello" .. "World", number + 1
\end{lstlisting}

Переменной \emph{str} будет присвоено значение \emph{Hello World}, в то время как значение переменной \emph{number} увеличится на единицу. 

В Lua сначала производится оценка переменных, а затем выполняется присваивание. Благодаря этому, мы можем произвести обмен значениями переменых за один шаг

\begin{lstlisting}
 x, y = y, x                -- swap \emph{x} and \emph{y}
 a[i], a[j] = a[j], a[i]    -- swap \emph{a[i]} and \emph{a[j]}
\end{lstlisting}

Если количество переменных отлично от количества значений, то:
\begin{itemize}
	\item 1) если количество переменных больше количества значений, то переменым, которым не представлены значения получат значение \emph{nil}
	\item 2) если количество переменных меньше количества значений, то лишние значения будут проигнорированы
\end{itemize}


\begin{lstlisting}
    a, b, c =  1, 2
    print(a,b,c)           --> 1  2   nil
    a, b = 1, 2, 3   	   -- 3 ignores
    print(a,b)             --> 1   2
    a, b, c = "Hello"
    print(a,b,c)           --> "Hello"   nil   nil
\end{lstlisting}

\subsection{ Блоки. Глобальные и локальные переменные.} 

Блок ограничивает логически сгруппированный набор  идущих подряд инструкций и ограничивает область видимости переменных. Блоком является любая управляющая конструкция(циклы, условные констуркции после then и else, функции). Блоки могут быть вложенными. Для создания блока используется конструкция \emph{do}-\emph{end}.
\begin{lstlisting}
	do
       --some instructions
    end         
\end{lstlisting}

\begin{lstlisting}
   str = "Hello World"      -- global
   local x = 10 			-- local
\end{lstlisting}

Все переменные объявленые в lua в любом блоке являются глобальными, если они не помечены служебным словом \emph{local}.
\emph{local} указывает на то, что переменная будет локальна, то есть сущесвтует только в пределах блока, в котором она объявлена. 

\begin{lstlisting}
 x = 10
 i = 1  
    
 while i<=x do
    local x = i*2     -- local for "while" body
    print(x)          --> 2, 4, 6, 8, ...
    i = i + 1
  end
  
 if i > 20 then
     local x           -- local for "then" body
     x = 20
     print(x + 2)	  --> 22
 else
     print(x)         --> 10 (global)
 end
    
 print(x)             --> 10 (global)
\end{lstlisting}

  